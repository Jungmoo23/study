이미지뷰를 xml 레이아우셍 추가해서 화면에 보여줄 때 이미지가 나타나는 영역보다 원본 이미지가 작으면 시스템이 이미지 크기를 자동으로 늘려줍니다. 이 기능은 해상도가 서로 다른 단말에서도 일정한 비율로 이미지의 크기를 지정하면 이미지가 자동으로 그 크기에 맞게 늘어나거나 줄어들게 하므로 아주 유용한 기능입니다.

나인패치는 이미지가 늘어나거나 줄어들 때 생기는 이미지가 왜곡을 해결하는 방법을 정의.
이렇게 수정한 이미지의 파일 이름은 xxx.9.png 처럼 파일 파일 확장자 앞에 .9를 붙여야 합니다. 이 방식으로 이름을 지은 파일을 원본 이미지의 가로, 세로 끝부분의 픽셀을 모두 나인패치 이미지의 정보를 담은 것으로 인식합니다. 이 정보는 흰색인 경우 늘어나지 않는 영역, 검은색인 경우 늘어나는 영역으로 구분되는데 위의 그림과 같이 지정하면 가운데 부분만 늘어나므로 이미지의 크기가 커지더라도 모서리 부분은 원래의 이미지 모양을 유지할 수 있습니다.

7-2 새로운 뷰 만들기
API에서 제공하는 위젯을 사용하려면 API의 뷰를 상속해야 합니다.
그리고 API의 뷰를 상속하여 새로운 뷰를 만들 때는 뷰가 그려지는 방법을 반드시 이해해야 합니다. 뷰위 영역과 크기는 그 뷰를 포함하고 있는 레이아웃의 영향을 받아 정해집니다. 이때 개발자가 뷰의 상태에 따라 추가적인 코드를 넣을 수 있도록 콜백 메서드가 호출됩니다. 뷰가 스스로의 크기를 정할 때 자동으로 호출되는 메서드는 onMeaure이고 스스로를 레이아웃에 맞게 그릴 때는 onDraw 메서드가 자동으로 호출이 된다.

onMeaure 메서드의 파라미터로 전달되는 widthMeasureSpec과 heightMeasurespec은 이 뷰를 담고 있는 레이아웃에서 이 뷰에게 허용하는 여유 공간의 폭과 높이에 대한 정보입니다. 즉 부모 컨테이너에서 여유 공간에 대한 정보를 전달하는데 이 값을 참조하여 뷰가 보일 적절한 크기를 반환하면 이 크기 값으로 뷰가 그려지게 됩니다. onMeasure 메서드 안에서 이 뷰를 담고 있는 레이아웃에게 이 뷰의 크기 값을 반환하고 싶다면 다음 메서드를 사용합니다.

Ondraw 메서드와 invalidate메서드 이해하기
뷰가 화면에 보일 때는 onDraw 메서드가 호출됩니다. 예를 들어 버튼의 경우에 그림으로 된 아이콘이나 글자가 그 위에 표시되려면 먼저 그 버튼을 담고 있는 레이아웃에 따라 버튼의 위치와 크기가 정해져야 합니다. 그런 다음 버튼의 모양과 그 안의 아이콘 또는 글자를 화면상에 그려주는 과정을 거차게 됩니다. 이렇게 그려지는 과정을 거치게 됩니다. 이렇게 그려지는 과정에서 호출되는 onDraw메서드를 다시 정의하면 여러분이 보여주려는 내용물을 버튼위에 그릴 수 있습니다.

결국 새로운 뷰를 클래스로 정의하고 그 안에 onDraw 메서드를 다시 정의한 후 필요한 코드를 넣어 기능을 구현하면 다른 모양으로 보이는 뷰를 직접 만들 수 있는 것입니다.

뷰 위에 그래픽을 그리는 과정을 설명하는 그림에서 볼 수 있듯이 새로 정의한 myView클래스의 onDraw메서드는 뷰가 화면에 보이기 전에 호출되므로 이 메서드 안에서 원하는 모양의 그래픽을 화면에 그리면 그 모양대로 화면에 표현할 수 있습니다. 또한 손가락으로 터치하여 화면에 그려진 뷰를 이동시키려고 할 떄는 뷰가 이동한 후에 그 뷰의 그래픽을 다시 그려야 할 필요가 있는데 이 때 invalidate 메서드를 호출하면 됩니다. invalidate메서드가 호출되면 자동으로 onDraw 메서드가 다시 호출되어 이동한 좌표에 뷰의 그래픽을 다시 그리도록 만들 수 있습니다.

AppcompatButton에는 버튼을 위한 기능이 미리 정의되어 있으며 Appcompatwidget패키지 안에 들어 있음.
생성자를 추가할 수 있는 대화상자에는 세 개의 메서드가 표시되는데 그중에서 두 개가 필수 생성자 입니다.
첫 번째 생성자는 Context객체만 파라미터로 전달받으면 두 번쨰 생성자는 Context객체와attributeSet 객체를 파라미터로 전달받습니다.
안드로이드는 UI 객체를 만들 때 Context 객체를 전달 받도록 되어 있으므로 생성자에는 항상 Context 객체가 전달되어야 합니다. 
attributeSet객체는 XML레이아웃에서 태그에 추가하는 속성을 전달받기 위한 것으로 이 뷰를 XML 레이아웃에서 태그에 추가하는 속성을 전달받기 위한 것으로 이 뷰를 XML 레이아웃에 추가하는 경우 이 두 번째 생성자가 사용됩니다. 첫 번째 생성자는 이 뷰를 소스 코드에서 new 연산자로 생성하는 경우에 사용됩니다. 두 개의 생성자를 선택하고 ok ㅂㅓ튼을 누르면 두 개의 생성자가 소스 파일에 추가 됩니다.
생성자가 두 개이므로 이 뷰가 초기화될 떄 필요한 코드는 init 메서드를 만들어 그 안에 정의합니다. 이렇게 하면 두 개의 생성자에서 모두 init 메서드를 호출하도록 할 수 있어 어떤 생성자가 호출되든 상관업싱 동일한 초기화 작업이 진행되도록 만들 수 있음.

Dimensions.xml 파일은 크기 값 등을 정의할 수 있는 파일입니다. 이 파일의 리소스 태그 안에 디멘션 태그를 추가하고 dp, sp 또는 다른 단위의 크기 값을 정의하면 소스 코드에서 그 값을 참조할  있습니다.

Invalidate 메서드를 호출하여 뷰를 다시 드립니다. 뷰가 다시 그려진다면 onDraw메서드가 동작이 됨.

07-03레이아웃 정의하고 카드뷰 넣기
카드뷰는 프로필과 같은 간단 정보를 넣기 위해 각 영역을 구분하는 역활을 합니다. 예을 들어 쇼핑몰 앱에서 하나의 상품 정보를 상품 이미지와 가격 그리고 평점으로 표시하고자 한다면 이것들을 카드뷰 안에 넣어서 표시 할 수 있습니다.

레이아웃은 뷰들을 그 안에 배치하고 보여주어야 하므로 하나의 xml 레이아웃파일고 ㅏ하나의 소스파일로 구성됩니다. 즉 액티비티가 그렇듯이 레이아웃으로 만들어지는 부분 화면도 두 개의 파일로 구성 됩니다. 즉 액티비티가 그렇듯이 레이아웃으로 만들어지는 부분 화면도 두 개의 파일로 구성됩니다.

LayoutInflater객체를 참조. 객체는 시스템 서비스로 제공되므로 getSystemService메서드를 호출하면서 파라미터로 Context.LAYOUT_INFLATERSERVICE 상수를 전달하면 객체가 반환됩니다. 이 객체는 inflate 메서드를 호출하면서 xml 레이아웃 파일을 파라미털 전달하면 인플레이션이 진행되면서 이 소스 파일에 설정됩니다.

인플레이션 과정이 끝나면 XML 레이아웃 파일 안에 넣어둔 이미지뷰나 텍스트 뷰를 찾아서 참조할 수 있습니다. 택티비티에 사용했던 findviewById메서드를 동일하게 호출할 수 잇으므로 inflate메서드를 호출한 코드 아래의 findviewbyid를 이용해 이미지뷰와 텍스트뷰를 찾아내는 코드를 추가합니다.

CardView 태그로 추가할 때는 패키지 이름이 androids.cardview.widget까지 같이 입력합니다.
모서리를 둥글게 만들 수 있는 cardCornerradius, 그리고 뷰가 올라온 느낌이 들도록 하는 cardElevation 속성이 있습니다.

7-4리싸이클러뷰 만들기
모바일 단말에서 가장 많이 사용되는 ui 모양 중의 하나가 바로 리스트입니다. 리스트는 일반적으로 여러 개의 아이템 증 하나를 선택할 수 있는 세로 모양으로 된 화면 컨트롤을 말하는데 이런 UI 모양은  다른 언어에서도 많이 사용됩니다.

스마트폰의 사용성을 높이기 위해 리스트가 자주 사용 돼요
손가락을 사용하는 아이폰과 안드로이드폰은 작은 크기의 테이블 셀을 터치하기 힘들기 때문에 리스트 모양으로 큼직하게 만드는 것이 사용성을 높이는 대표적인 방법입니다.

안드로이드에서는 여러 개의 아이템 중에 하나를 선택할 수 있는 리스트 모양의 위젯을 특별히 선택 위젯이라고 부른다.
선택 기능을 가진 위젯을 특별히 구별하는 이유는 사용되는 방식이 다른 위젯과 약간 다르기 떄문이다.

선택 위젯을 일반 위젯과 구분하는 이유는 선택 위젯이 어댑터 패턴을 사용하기 때문이다. 선택 위젯에 데이터를 넣을 때 위젯이 아닌 어댑터에 설정해야 하며 화면에 보이는 뷰도 어댑터에서 만듭니다. 즉 리스트 모양의 뷰에 보이는 각각의 아이템은 뷰가 아닌 어댑터에서 관리합니다.

선택할 수 있는 여러 개의 아이템이 표시되는 선택 위젯은 어댑터를 통해 각각의 아이템을 화면에 보여줍니다. 따라서 원본 데이터는 어댑터에 설정해야 하며 어댑터가 데이터 관리 기능을 담당합니다. 그리고 각각의 아이템을 위한 뷰도 위젯에 전달합니다. 즉 위젯은 각 앙템을 보여주기만 할 뿐 각 아이템을 위한 뷰는 어댑터가 만듭니다.

또한 어댑터에서 만들어 반환하는 뷰가 텍스트뷰나 버튼과 같은 하나의 뷰가 아니라 리니어 레이아웃처럼 여러 개의 뷰들을 담고 있는 레이아웃이라면 하나의 레이아읏 안에 여러 개의 뷰들이 들어가게 됩니다.

리싸이클러뷰는 기본적으로 상하 스크롤이 가능하지만 좌우 스크롤도 만들 수 있습니다. 왜냐하면 처음 만들어질 때 부터 레이아웃을 유연하게 구성할 수 있도록 설계되었기 때문입니다. 그리고 각각의 아이템이 화면에 보일 때 메모리를 효율적으로 사용하도록 캐시 매커니즘이 구현되어 있습니다.

리스트 형태로 보일 때 각각의 아이템은 뷰로 만들어지며 각각의 아이템을 위한 뷰는 뷰홀더에 담아두게 됩니다. 이 뷰홀더 역활을 하는 클래스를 PersonAdapter 클래스 안에 넣어둔다고 생각하면 됩니다.

Recycleview.Adapter 필수적으로 3가지를 구현해야함
getItemCount 메서드는 어댑터에관리하는 아이템의 개수를 반환합니다. 이 메서드는 리 싸이클러뷰에서 어댑터가 관리하는 아이템의 개수를 알아야 할 때 사용합니다. 
OnCreateViewHolder와 onBIndViewHolder 메서드는 뷰홀더 객체가 만들어질 때와 재사용될 때 자동으로 호출됩니다.  리싸이클러뷰에 보이는 여러개의 아이템은 내부에서 캐시되기 때문에 아이템 개수만큼 객체로 만들어 지지는 않습니다. 예을 들어 아이템이 천 개라고 하더라도 이 아이템을 위해 천개의 뷰 객체가 만들어지지 않습니다. 메모리를 효율적으로 사용하려면 뷰 홀더에 뷰 객체를 넣어두고 사용자가 스크롤하여 보이진 않게 된 뷰 객체를 새로 보일 쪽에 재사용하는 거시 효율적이기 때문이다.

뷰홀더가 새로 만들어지는 시점에는 onCreateViewHolder 메서드가 호출되므로 그안에서는 각 아이템을 위해 정의한 xml 레이아웃을 이용해 뷰 객체를 만들어줍니다. 그리고 뷰 객체를 새로 만든 뷰 홀더 객체에 담아 반환합니다. 

뷰홀더가 새로 만들어지는 시점에는 onCreateViewHolder메서드가 호출되므로 그 안에서는 각 아이템을 위해 정의한 XML 레이아웃을 이용해 뷰 객체를 만들어 줍니다. 그리고 뷰 객체를 새로 만든 뷰홀더 객체 담아 반환합니다. 
onBindViewHolder 메서드는 뷰홀더가 재사용될 때 호출되므로 뷰 객체는 기존 것을 그대로 사용하고 데이터만 바꿔줍니다.

onCreateViewHolder 메서드 안에서 인플레이션을 진행하기 위해서 context객체가 필요한데 파라미터로 전달되는 뷰그룹 객체의 getContext 메서드를 이용하면 Context 객체를 참조할 수 있습니다. 파라미터로 전달되는 뷰그룹 객체는 각 아이템을 위한 뷰그룹 객체이므로 xml 레이아웃을 인플레이션하여 이 뷰그룹 객체에 설정합니다.

onBIndViewHolder 메서드는 재활용할 수 있는 뷰홀더 객체를 파라미터로 전달하기 때문에 그 뷰홀더에 현재 아이템에 맞는 데이터만 설정합니다. 데이터는 Person 객체로 만드는데 여러 아이템을 이 어댑터에서 관리해야 하기 때문에 클래스 안에 ArrayList에서 알아야 하므로 getItemCount 메서드는 ArrayList의 size 메서드를 호출하여 전체 아이템이 몇개인지를 확인한 후 그 값을 반환합니다.

리싸이클러뷰에는 레이아웃 매니저를 설정할 수 있습니다. 레이아웃 매니저는 리싸이클러뷰가 보일 기본적인 형태를 설정할 때 사용하는데 자주 사용하는 형태는 세로 방향(스마트폰 세로), 가로 방향(스마트폰 가로 방향), 격자 모양(GridLayoutManager)입니다.
레이아웃 매니저 객체를 설정하기 위해 setLayoutManager메서드를 호출합니다.

7-5 스피너 사용하기
리스트나 격자 모양으로 여러 아이템을 보여주는 경우가 많지만 그 외에도 여러 아이템 중에서 하나를 선택하는 전형적인 위젯으로 스피너를 들 수 있습니다. 스피너는 일반적으로 윈도우에서 콤보박스로 부릅니다.
스피너는 <Spinner>태그를 사용해 xml 레이아웃에 추가한 후 사용할 수 있습니다.

스피너 리스너: onItemSelected
setAdapter

import androidx.appcompat.app.AppCompatActivity;

import android.os.Bundle;
import android.view.View;
import android.widget.AdapterView;
import android.widget.ArrayAdapter;
import android.widget.Spinner;
import android.widget.TextView;

public class MainActivity extends AppCompatActivity {

    //스피너 구성을 위한 문자열 배열
    String[] data1 = {
            "스피너1","스피너2","스피너3","스피너4","스피너5","스피너6","스피너7","스피너8"
    };
    //뷰의 주소 값을 참조 변수
    Spinner spin1;
    TextView t1;
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        //뷰에 주소를 담는다.
        spin1 = (Spinner)findViewById(R.id.spinner);
        t1 = (TextView)findViewById(R.id.textView);

        //어뎁터를 생성한다.
        ArrayAdapter<String> ap = new ArrayAdapter<String>(this, android.R.layout.simple_spinner_item,data1);
        //드롭 다운으로 나타나는 항목 리스트의 뷰
        ap.setDropDownViewResource(android.R.layout.simple_spinner_dropdown_item);
        //어뎁터를 스피너에 적용한다.
        spin1.setAdapter(ap);

        //리스너를 셋팅한다.
        Spinnerr sp = new Spinnerr();
        spin1.setOnItemSelectedListener(sp);
    }

    public void btnMehold(View view){
        //현재 스피너에 선택되어 있는 항목의 인덱스 값을 추출한다.
        int index = spin1.getSelectedItemPosition();
        t1.setText("선택된 항목 : "+data1[index]);
    }

    class Spinnerr implements AdapterView.OnItemSelectedListener{
        //사용자가 항목을 선택했을 때 호출되는 메서드
        @Override
        public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
            t1.setText(data1[position]);
        }

        @Override
        public void onNothingSelected(AdapterView<?> parent) {

        }

    }


}


ArrayAdapter(context 객체, xml, 어떤 것을 할지)
